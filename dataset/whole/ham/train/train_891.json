{
    "headers": "Return-Path: <fork-admin@xent.com>\nDelivered-To: yyyy@localhost.example.com\nReceived: from localhost (jalapeno [127.0.0.1])\tby jmason.org (Postfix) with ESMTP id D05D716F7D\tfor <jm@localhost>; Wed,  4 Sep 2002 11:40:07 +0100 (IST)\nReceived: from jalapeno [127.0.0.1]\tby localhost with IMAP (fetchmail-5.9.0)\tfor jm@localhost (single-drop); Wed, 04 Sep 2002 11:40:07 +0100 (IST)\nReceived: from xent.com ([64.161.22.236]) by dogma.slashnull.org    (8.11.6/8.11.6) with ESMTP id g842TMZ16374 for <jm@jmason.org>;    Wed, 4 Sep 2002 03:29:22 +0100\nReceived: from lair.xent.com (localhost [127.0.0.1]) by xent.com (Postfix)    with ESMTP id 7910E2941D0; Tue,  3 Sep 2002 19:23:02 -0700 (PDT)\nDelivered-To: fork@example.com\nReceived: from mithral.com (watcher.mithral.com [204.153.244.1]) by    xent.com (Postfix) with SMTP id CED692941CF for <fork@xent.com>;    Tue,  3 Sep 2002 19:22:11 -0700 (PDT)\nReceived: (qmail 13312 invoked by uid 1111); 4 Sep 2002 02:24:24 -0000\nFrom: \"Adam L. Beberg\" <beberg@mithral.com>\nTo: Kragen Sitaker <kragen@pobox.com>\nCc: fork@example.com\nSubject: Re: asynchronous I/O (was Re: Gasp!)\nIn-Reply-To: <20020903221730.D93F83F4EB@panacea.canonical.org>\nMessage-Id: <Pine.LNX.4.33.0209031924180.13303-100000@watcher.mithral.com>\nMIME-Version: 1.0\nContent-Type: TEXT/PLAIN; charset=\"US-ASCII\"\nSender: fork-admin@xent.com\nErrors-To: fork-admin@xent.com\nX-Beenthere: fork@example.com\nX-Mailman-Version: 2.0.11\nPrecedence: bulk\nList-Help: <mailto:fork-request@xent.com?subject=help>\nList-Post: <mailto:fork@example.com>\nList-Subscribe: <http://xent.com/mailman/listinfo/fork>, <mailto:fork-request@xent.com?subject=subscribe>\nList-Id: Friends of Rohit Khare <fork.xent.com>\nList-Unsubscribe: <http://xent.com/mailman/listinfo/fork>,    <mailto:fork-request@xent.com?subject=unsubscribe>\nList-Archive: <http://xent.com/pipermail/fork/>\nDate: Tue, 03 Sep 2002 19:24:24 -0700\nX-Spam-Status: No, hits=-10.2 required=7.0\ttests=AWL,EMAIL_ATTRIBUTION,IN_REP_TO,KNOWN_MAILING_LIST,\t      QUOTED_EMAIL_TEXT,SPAM_PHRASE_00_01,USER_AGENT_PINE\tversion=2.41-cvs\nX-Spam-Level: ",
    "subject": "Re: asynchronous I/O (was Re: Gasp!)",
    "body": "On Tue, 3 Sep 2002, Kragen Sitaker wrote:\n> Of course we've had select() since BSD 4.2 and poll() since System V\n> or so, and they work reasonably well for asynchronous I/O up to a\n> hundred or so channels, but suck after that; /dev/poll (available in\n> Solaris and Linux) is one approach to solving this; Linux has a way to\n> do essentially the same thing with real-time signals, and has for\n> years; and FreeBSD has kqueue.\n>\n> More details about these are at\n> \n>\n> None of this helps with disk I/O; most programs that need to overlap\n> disk I/O with computation, on either proprietary Unixes or Linux, just\n> use multiple threads or processes to handle the disk I/O.\n>\n> POSIX specifies a mechanism for nonblocking disk I/O that most\n> proprietary Unixes implement. The Linux kernel hackers are currently\n> rewriting Linux's entire I/O subsystem essentially from scratch to\n> work asynchronously, because they can easily build efficient\n> synchronous I/O primitives from asynchronous ones, but not the other\n> way around. So now Linux will support this mechanism too.\n>\n> It probably doesn't need saying for anyone who's read Beberg saying\n> things like \"Memory management is a non-issue for anyone that has any\n> idea at all how the hardware functions,\" but he's totally off-base.\n> People should know by now not to take anything he says seriously, but\n> apparently some don't, so I'll rebut.\n>\n> Not surprisingly, the rebuttal requires many more words than the\n> original stupid errors.\n>\n> In detail, he wrote:\n> > Could it be? After 20 years without this feature UNIX finally\n> > catches up to Windows and has I/O that doesnt [sic] totally suck for\n> > nontrivial apps? No way!\n>\n> Unix acquired nonblocking I/O in the form of select() about 23 years\n> ago, and Solaris has had the particular aio_* calls we are discussing\n> for many years. Very few applications need the aio_* calls ---\n> essentially only high-performance RDBMS servers even benefit from them\n> at all, and most of those have been faking it fine for a while with\n> multiple threads or processes. This just provides a modicum of extra\n> performance.\n>\n> > OK, so they do it with signals or a flag, which is completely\n> > ghetto, but at least they are trying. Keep trying guys, you got the\n> > idea, but not the clue.\n>\n> Readers can judge who lacks the clue here.\n>\n> > The Windows I/O model does definately [sic] blow the doors off the\n> > UNIX one, but then they had select to point at in it's [sic]\n> > suckiness and anything would have been an improvement. UNIX is just\n> > now looking at it's [sic] I/O model and adapting to a multiprocess\n> > multithreaded world so it's gonna be years yet before a posix API\n> > comes out of it.\n>\n> Although I don't have a copy of the spec handy, I think the aio_* APIs\n> come from the POSIX spec IEEE Std 1003.1-1990, section 6.7.9, which is\n> 13 years old, and which I think documented then-current practice.\n> They might be even older than that.\n>\n> Unix has been multiprocess since 1969, and most Unix implementations\n> have supported multithreading for a decade or more.\n>\n> > Bottom line is the \"do stuff when something happens\" model turned\n> > out to be right, and the UNIX \"look for something to do and keep\n> > looking till you find it no matter how many times you have to look\"\n> > is not really working so great anymore.\n>\n> Linux's aio_* routines can notify the process of their completion with\n> a \"signal\", a feature missing in Microsoft Windows; a \"signal\" causes\n> the immediate execution of a \"signal handler\" in a process. By\n> contrast, the Microsoft Windows mechanisms to do similar things (such\n> as completion ports) do not deliver a notification until the process\n> polls them.\n>\n> I don't think signals are a better way to do things in this case\n> (although I haven't written any RDBMSes myself), but you got the\n> technical descriptions of the two operating systems exactly backwards.\n> Most programs that use Linux real-time signals for asynchronous\n> network I/O, in fact, block the signal in question and poll the signal\n> queue in a very Windowsish way, using sigtimedwait() or sigwaitinfo().\n>\n> --\n> <kragen@pobox.com> Kragen Sitaker <>\n> Edsger Wybe Dijkstra died in August of 2002. This is a terrible loss after\n> which the world will never be the same.\n> \n>\n- Adam L. \"Duncan\" Beberg\n \n beberg@mithral.com\n",
    "urls": [
        "http://www.citi.umich.edu/projects/linux-scalability/",
        "http://www.pobox.com/~kragen/",
        "http://www.xent.com/pipermail/fork/2002-August/013974.html",
        "http://www.mithral.com/~beberg/"
    ]
}